package com.gmail.s3cur3.hadoop_test;

/** 2-dimensional Halton sequence {H(i)},
 * where H(i) is a 2-dimensional point and i >= 1 is the index.
 * Halton sequence is used to generate sample points for Pi estimation.
 */
public class HaltonSequence {
    /** Bases */
    static final int[] P = {2, 3};
    /** Maximum number of digits allowed */
    static final int[] K = {63, 40};

    private long index;
    private double[] x;
    private double[][] q;
    private int[][] d;

    /** Initialize to H(startindex),
     * so the sequence begins with H(startindex+1).
     */
    HaltonSequence(long startindex) {
        index = startindex;
        x = new double[K.length];
        q = new double[K.length][];
        d = new int[K.length][];
        for(int i = 0; i < K.length; i++) {
            q[i] = new double[K[i]];
            d[i] = new int[K[i]];
        }

        for(int i = 0; i < K.length; i++) {
            long k = index;
            x[i] = 0;

            for(int j = 0; j < K[i]; j++) {
                q[i][j] = (j == 0? 1.0: q[i][j-1])/P[i];
                d[i][j] = (int)(k % P[i]);
                k = (k - d[i][j])/P[i];
                x[i] += d[i][j] * q[i][j];
            }
        }
    }

    /** Compute next point.
     * Assume the current point is H(index).
     * Compute H(index+1).
     *
     * @return a 2-dimensional point with coordinates in [0,1)^2
     */
    double[] nextPoint() {
        index++;
        for(int i = 0; i < K.length; i++) {
            for(int j = 0; j < K[i]; j++) {
                d[i][j]++;
                x[i] += q[i][j];
                if (d[i][j] < P[i]) {
                    break;
                }
                d[i][j] = 0;
                x[i] -= (j == 0? 1.0: q[i][j-1]);
            }
        }
        return x;
    }
}
